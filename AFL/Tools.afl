/* 
 * Copyright (C)2017 PT. Stosia Teknologi Investasi
 *
 * File ini  berlisensi  GNU GPL (General Public License)  versi 3. Artinya
 * kalau Anda  memodifikasi file ini, atau membuat karya lain yang berbasis
 * file ini  ("derivative work"),  maka Anda  wajib  mendistribusikan  kode
 * sumber ("source code")  modifikasi  atau karya  tersebut  kepada publik.
 * Hal ini untuk menjaga keterbukaan pengetahuan di masa mendatang.
 *
 * Silakan memakai kode ini untuk kepentingan apapun termasuk untuk mencari
 * profit,  asal tidak jahat.  Sebagai tambahan permintaan, kami menghimbau
 * untuk  TIDAK  menjual kode/file ini secara apa adanya  atau dalam bundel
 * produk yang dijual secara komersial, karena hal itu tidak etis.
 *
 * Untuk penjelasan lebih lanjut silakan bertanya kepada kami.  Untuk detil
 * lisensi GPLv3  silakan lihat file GPLv3-LICENSE.md  yang didistribusikan
 * bersama file ini.
 */
MILYAR = 1000000000.0;

Open = Ref(Close, -1);

//
// Connect to ODBC database
//
function stConnectDatabase()
{
	odbcOpenDatabase( "ODBC;DSN=quant.id");
}

//
// Set the text to be put as chart background
//
function stSetBackgroundTitle( txt )
{
	height = Status("pxheight");
	titleFontHeight = height/3;
	
	GfxSetOverlayMode(1);
	GfxSelectFont("Tahoma", titleFontHeight );
	GfxSetTextAlign( 6 );// center alignment
	GfxSetTextColor( ColorRGB( 220, 220, 220 ) );
	GfxSetBkMode(1); // transparent
	GfxTextOut( txt, Status("pxwidth")/2, height/50 - titleFontHeight/8);
}

//
// Set the second line in of the text to be put as chart background
//
function stSetBackgroundSubtitle( txt )
{
	height = Status("pxheight");
	titleFontHeight = height/3;
	subtitleFontHeight = height/10;
	spacing = height/100;
	
	GfxSetOverlayMode(1);
	GfxSelectFont("Tahoma",  subtitleFontHeight);
	GfxSetTextAlign( 6 );// center alignment
	GfxSetTextColor( ColorRGB( 220, 220, 220 ) );
	GfxSetBkMode(1); // transparent
	GfxTextOut( txt, Status("pxwidth")/2,  
				height/50 + titleFontHeight + subtitleFontHeight + spacing);
}

//
// Set the third line in of the text to be put as chart background
//
function stSetBackgroundSubSubtitle( txt )
{
	height = Status("pxheight");
	titleFontHeight = height/3;
	subtitleFontHeight = height/10;
	subsubtitleFontHeight = height/15;
	spacing = height/100;
	
	GfxSetOverlayMode(1);
	GfxSelectFont("Tahoma", subsubtitleFontHeight );
	GfxSetTextAlign( 6 );// center alignment
	GfxSetTextColor( ColorRGB( 220, 220, 220 ) );
	GfxSetBkMode(1); // transparent
	GfxTextOut( txt, Status("pxwidth")/2,  
				height/50 + titleFontHeight + 2*subtitleFontHeight + 
					2*spacing + subsubtitleFontHeight);
}

//
// Display MessageBox in the chart
//
function stMessageBox( txt, color, bkcolor )
{
	fontFace = "Arial";
	fontSize = 12;
	
	x = Status("pxwidth")/2;
	y = 20;
	
	GfxSetOverlayMode(0);
	GfxSelectFont(fontFace, fontSize);
	GfxSetTextAlign( 6 );// center alignment
	GfxSetTextColor(color);
	GfxSetBkColor(bkcolor);
	GfxSetBkMode(2); // opaque
	GfxTextOut( txt, x,  y);

}

//
// Display error message
//
function stAlert(txt)
{
	stMessageBox(txt, colorWhite, colorRed);
}

//
// Display recommendation in the chart.
//
// Parameters:
//  - goodness: range from -2 to +2, where -2 is strong sell and +2 is strong buy
//  - txt: OPTIONAL text. If empty, default is set based on goodness:
//          - -2: "SSELL"
//          - -1: "SELL"
//          - 0: "HOLD"
//          - +1: "BUY"
//          - +2: "SBUY"
//
function stDisplaySignal( goodness, txt )
{
	if (goodness >= 2) {
		color = colorWhite;
		bkColor = colorBrightGreen;
		myText = "SBUY";
	} else if (goodness >= 1) {
		color = colorWhite;
		bkColor = colorGreen;
		myText = "BUY";
	} else if (goodness == 0) {
		color = colorWhite;
		bkColor = colorLightGrey;
		myText = "HOLD";
	} else if (goodness == -1) {
		color = colorWhite;
		bkColor = colorLightOrange;
		myText = "SELL";
	} else {
		color = colorWhite;
		bkColor = colorRed;
		myText = "SSELL";
	}
	
	if (txt == "")
		txt = myText;
		
	GfxSetOverlayMode(1);
	GfxSelectFont("Lucida Console", 10, 800 );
	GfxSetTextAlign( 2  );
	GfxSetTextColor( color );
	GfxSetBkColor( bkColor );
	GfxSetBkMode( 2 );
	GfxTextOut( txt, Status("pxwidth")-62, 0 );
}

//
// Get current date in ISO format
//
function stISOToday()
{
	n = Now(5);
	return DateTimeToStr(n, 4);
}

//
// Convert DateNum to ISO date string
//
function stDateNumToStr(dn)
{
	dt = DateTimeConvert(2, dn);
	return DateTimeToStr(dt, 4);
}

//
// For intraday, the MA should not use value from previous day
//
function stIntradayMA(arr, range)
{
	prev_dn = -1;
	dn = DateNum();
	
	for (i=0; i<BarCount; ++i) {
		if (dn[i] != prev_dn) {
			total = arr[i];
			count = 1;
		} else {
			if (count < range) {
				count += 1;
				total += arr[i];
			} else {
				total = total - arr[i - range] + arr[i];
			}
		}
		
		result[i] = total * 1.0 / count;
	}

	return result;
}

//
// Calculate simple MA for the array with provision for intraday.
//
function stMA(arr, range)
{
	if (Interval() >= inDaily) {
		result = MA(arr, range);
	} else {
		result = stIntradayMA(arr, range);
	}
	return result;
}

//
// Return the typical price (i.e. (H + L + C) / 3)
//
function stTypicalPrice()
{
	return (H + L + C) / 3;
}

//
// General purpose function to calculate the SUM of an array 
// over certain days. For example if "days" is 2, then calculate
// daily sum for the past two days.
//
function stSumDays(array, days)
{
	//dn = DateNum();
	dn = DaysSince1900();
	
	for (i=0; i<BarCount; ++i) {
		result[i] = array[i];
		bars[i] = 1;

		days_found = 1;
		last_day = dn[i];
		
		for (j=i-1; j >= 0; j--) {
			if (dn[j] != last_day) {
				days_found++;
				last_day = dn[j];
			}
			
			if (days_found > days)
				break;
				
			result[i] += array[j];
			bars[i] += 1;
		}
	}
	
	return result;
}

//
// Fill the intraday array with the last value of the day
//
function stLastDayValue(array)
{
	dn = DateNum();
	
	cur_dn = -1;
	last_day_value = -1;
	
	for (i = BarCount-1; i >= 0; i--) {
		if (dn[i] != cur_dn) {
			cur_dn = dn[i];
			last_day_value = array[i];
		}
		result[i] = last_day_value;
	}
	
	return result;
}

//
// Calculate average price from buy and sell values.
// Returns the average price of the stock ownership.
// Also sets global variable stProfit to indicate the realized 
// profit (or loss) from the transactions.
//
function stGetAvgPrice(buyValue, buyShares, sellValue, sellShares)
{
	global stProfit;
	
	isIntraday = Interval() < inDaily;
	if (isIntraday) {
		_N(col = "int");
	} else {
		if (Interval() > inDaily) {
			stAlert("Error: Interval greater than daily is not supported yet!");
		}
		_N(col = "day");
	}

	buyAvg = IIf(buyShares >= 1, buyValue / buyShares, 0);
	sellAvg = IIf(sellShares >= 1, sellValue / sellShares, 0);
	
	netShares = buyShares - sellShares;
	
	dn = DateNum();
	prev_dn = -1;
	
	i = 0;
	if (IsEmpty(netShares[i])) {
		portoShares[i] = 0;
		portoAvg[i] = Null;
		stProfit[i] = Null;
		branch[i] = 10;
	} else if (netShares[i] >= 0) {
		portoShares[i] = netShares[i];
		portoAvg[i] = buyAvg[i];
		stProfit[i] = netShares[i] * (sellAvg[i] - buyAvg[i]);
		branch[i] = 20;
	} else {
		portoShares[i] = 0;
		portoAvg[i] = Null;
		stProfit[i] = sellShares[i] * (sellAvg[i] - buyAvg[i]);
		branch[i] = 30;
	}

	for (i=1; i<BarCount; ++i) {
		if (IsEmpty(netShares[i])) {
			branch[i] = 40;
			portoShares[i] = 0;
			portoAvg[i] = Null;
			stProfit[i] = stProfit[i-1];
		} else if (dn[i] != prev_dn && isIntraday) {
			branch[i] = 50;
			// Reset on new day
			if (netShares[i] >= 0) {
				branch[i] = 53;
				portoShares[i] = netShares[i];
				portoAvg[i] = buyAvg[i];
				stProfit[i] = netShares[i] * (sellAvg[i] - buyAvg[i]);
			} else {
				branch[i] = 56;
				portoShares[i] = 0;
				portoAvg[i] = Null;
				stProfit[i] = sellShares[i] * (sellAvg[i] - buyAvg[i]);
			}
			prev_dn = dn[i];
			
		} else {
			branch[i] = 60;
			portoShares[i] = portoShares[i-1] + buyShares[i];
			if (portoShares[i]) {
				if (IsEmpty(portoAvg[i-1])) {
					portoAvg[i] = buyAvg[i];
					branch[i] = 62;
				} else {
					branch[i] = 64;
					portoAvg[i] = ((portoShares[i-1] * portoAvg[i-1]) + (buyShares[i] * buyAvg[i])) / portoShares[i];
				}
			} else {
				branch[i] = 66;
				portoAvg[i] = PortoAvg[i-1];
			}
			
			if (sellShares[i] >= portoShares[i]) {
				// All sold
				stProfit[i] = IIf(IsEmpty(stProfit[i-1]), 0, stProfit[i-1]) + (portoShares[i] * (sellAvg[i] - portoAvg[i]));
				portoShares[i] = 0;
			}  else {
				stProfit[i] = IIf(IsEmpty(stProfit[i-1]), 0, stProfit[i-1]) + (sellShares[i] * (sellAvg[i] - portoAvg[i]));
				portoShares[i] -= sellShares[i];
			}
		}
		
		if (portoAvg[i] == 0.0)
			portoAvg[i] = Null;
	}
	
	if (Status("ActionEx") == actionExplore) {
		//AddColumn(BarIndex(), "i", 1.0);
		//AddColumn(branch, "branch", 1.0);
		AddColumn(buyShares, "buyShares", 1.0);
		AddColumn(sellShares, "sellShares", 1.0);
		AddColumn(buyShares - sellShares, "netShares", 1.0);
		
		AddColumn(buyAvg, "buyAvg", 1.2);
		AddColumn(sellAvg, "sellAvg", 1.2);
		
		AddColumn(portoShares, "portoShares", 1.0);
		AddColumn(portoAvg, "portoAvg", 1.2);
		AddColumn(stProfit, "stProfit", 1.0);
	}
	return portoAvg;
}

//
// Simplified version of average price calculation.
// Calculate average price from net value for each interval
// Parameters:
//  - netValue: array of net value (in Milyar)
//
function stGetAveragePriceFromNetValue(netVal)
{
	netVal = netVal * MILYAR;
	
	typ = stTypicalPrice();

	dn = DateNum();
	prev_dn = -1;
	isIntraday = Interval() < inDaily;
	
	if (Interval() > inDaily) {
		stAlert("Error: Interval greater than daily is not supported yet");
	}

	i = 0;
	if (netVal[i] >= 0) {
		portoValue[i] = netVal[i];
		portoShares[i] = netVal[i] / typ[i];
		portoAvg[i] = typ[i];
	} else {
		portoValue[i] = 0;
		portoShares[i] = 0;
		portoAvg[i] = Null;
	}

	for (i=1; i<BarCount; ++i) {
		if (IsEmpty(netVal[i]) || (dn[i] != prev_dn && isIntraday)) {
			// Reset on new day
			if (netVal[i] >= 0) {
				portoValue[i] = netVal[i];
				portoShares[i] = netVal[i] / typ[i];
				portoAvg[i] = typ[i];
			} else {
				portoValue[i] = 0;
				portoShares[i] = 0;
				portoAvg[i] = Null;
			}
			
			prev_dn = dn[i];
		} else {
			portoValue[i] = portoValue[i-1] + netVal[i];
			portoShares[i] = portoShares[i-1] + (netVal[i] / typ[i]);
			
			if (portoValue[i] < 0 || portoShares[i] < 0) {
				// All sold
				portoValue[i] = 0;
				portoShares[i] = 0;
				portoAvg[i] = Null;
			} else if (i > 0 && netVal[i] < 0) {
				// Sell operation doesn't change avg
				portoAvg[i] = portoAvg[i-1];
				// Adjust balance
				portoValue[i] = portoShares[i] * portoAvg[i];
			} else {
				
				portoAvg[i] = portoValue[i] / portoShares[i];
			}
		}
	}
	
	/*	
	Plot(netVal, "netVal", colorBlack, styleNoLine | styleOwnScale | styleNoLabel);
	Plot(typ, "typ", colorBlack, styleNoLine | styleOwnScale | styleNoLabel);
	Plot(portoValue, "portoValue", colorBlack, styleNoLine | styleOwnScale | styleNoLabel);
	Plot(portoShares, "portoShares", colorBlack, styleNoLine | styleOwnScale | styleNoLabel);
	Plot(portoAvg, "portoAvg", colorBlack, styleNoLine | styleOwnScale | styleNoLabel);
	*/
	return portoAvg;
}

//
// Master chart signal that data is ready
//
function stMasterChartSignalReady(id)
{
	varname = "Chart" + id;
	value = Name() + "," + NumToStr(Interval()) + "," + NumToStr(SelectedValue(DateNum()));
	StaticVarSetText(varname, value);
}

//
// Slave chart wait until master is ready
//
function stSlaveChartWaitReady(id, timeoutSec)
{
	sleepDuration = 100;
	sleepCount = timeoutSec * 1000 / sleepDuration;
	
	varname = "Chart" + id;
	expected = Name() + "," + NumToStr(Interval()) + "," + NumToStr(SelectedValue(DateNum()));
	i = 0;
	while (True) {
		value = StaticVarGetText(varname);
		if (value == expected)
			break;
		
		i += 1;
		if (i > sleepCount) {
			stAlert("Error: timeout waiting for master chart signal");
			break;
		}
		
		ThreadSleep(sleepDuration);
	}
}

//
// Auto precision
//
function stAutoPrec(arr)
{
	precDigit = IIf(abs(arr[BarCount-1]) < 1, 3, 1);
	return Prec(arr, precDigit);
}
